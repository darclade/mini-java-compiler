/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options{  JDK_VERSION = "1.5";  static = true;}PARSER_BEGIN(javinha)package foo2;

public class javinha{  public static void main(String args []) throws ParseException  {    javinha parser = new javinha(System.in);    while (true)    {      System.out.println("Reading from standard inputES...");      System.out.print("Enter an expression like \"1+(2+3)*4;\" :");      try      {        switch (javinha.one_line())        {          case 0 :           System.out.println("OK.");          break;          case 1 :           System.out.println("Goodbye.");          break;          default :           break;        }      }      catch (Exception e)      {        System.out.println("NOK.");        System.out.println(e.getMessage());        javinha.ReInit(System.in);      }      catch (Error e)      {        System.out.println("Oops.");        System.out.println(e.getMessage());        break;      }    }  }}PARSER_END(javinha)SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN : /* OPERATORS */{  < PLUS : "+" >| < MINUS : "-" >| < MULTIPLY : "*" >| < AND : "&&" >
| < LTHEN : "<" >}

TOKEN :
{
  	< LENGHT : "lenght" >} 
TOKEN : //Class
{
  <  CLASS : "class" >
}

TOKEN :
{
  < PUBLIC : "public">}

TOKEN:{  <  EXTENDS : "extends" >}

TOKEN:{
  	< THIS : "this" >}

TOKEN:{
  < NEW : "new" >}

TOKEN : //integers{  < INTEGER_LITERAL : (< DIGIT >)+ >| < #DIGIT : [ "0"-"9" ] >}

TOKEN: //boolean values
{
  < BOOL : "true" | "false" >}
TOKEN:
{
  	< ID : ((< LIT >)(< LIT > | "_" | < DIGIT >)*)+>
	| < #LIT : (([ "A"-"Z" ]) | (["a"-"z"]))+ >}
TOKEN:
{
  < INT : "int" >}

TOKEN:
{
  < LPAREN : "(" >}

TOKEN:
{
  < RPAREN : ")" >
}

TOKEN:
{
  < LBRACK: "[" >
}

TOKEN:
{
  < RBRACK : "]" >
}

TOKEN:
{
  < BOOLEAN : "boolean" >
}

TOKEN:
{
  < WHILE : "while" >}

TOKEN:
{
  < IF : "if" >
}

TOKEN:
{
  < ELSE : "else" >
}
int Program() :{}{  MainClass() ( ClassDecl() )* ";"
  {
    return 0;
  }
| ";"
  {
    return 1;
  }}void MainClass() :{}{  < CLASS > < ID > "{ public static void main ( String []" < ID > ")"
               "{" Statement() "}""}"}
void ClassDecl() :
{}
{
  //< CLASS > < ID > ("{" ( VarDecl() )* ( MethodDecl() )* "}") |
  < CLASS > < ID > (< EXTENDS > | "" ) <ID > "{" ( VarDecl() )* ( MethodDecl() )* "}"
  

}

void VarDecl():
{}
{				   Type() < ID > ";"
}

void MethodDecl():
{}
{	   < PUBLIC > Type() < ID > < LPAREN > FormalList() < RPAREN > 
               "{" ( VarDecl() )* ( Statement() )* "return" Expression()";""}"             
}

void FormalList():
{}
{	   Type() < ID > ( FormalRest() )*
}

void FormalRest():
{}
{
	   ","Type()< ID > |
	   ""
}

void Type():
{}
{   < INT > ("[""]" | "") |
   < BOOLEAN > |
   //< INT > |
   < ID >
}

void Statement():
{}
{  "{" ( Statement() )* "}" |
  < IF > < LPAREN > Expression() < RPAREN > Statement() < ELSE > Statement() |
  < WHILE > < LPAREN > Expression() < RPAREN >  Statement() |
  "System.out.println" "(" Exp() ")" ";" |
  < ID > ("[" Expression() "]" | "" ) "=" Expression()";"
  //< ID > "=" Expression()";" |
  //< ID > "[" Expression() "]" "=" Expression()";"
}

void Expression():
{}
{
  Term() Exp()}  


void Exp():
{}
{
   (< PLUS > | < MINUS > | < MULTIPLY> | < AND > | < LTHEN >)+ Term()Exp() |
			   Expression() ( "." ( < LENGHT > | <ID > < LPAREN > ExpList() < RPAREN > ) | < LBRACK > Expression() < RBRACK > ) |
   //Expression() < LBRACK > Expression() < RBRACK > |
   //Expression()"." < LENGHT > |
   //Expression()"." <ID > < LPAREN > ExpList() < RPAREN > |
   ""   
  }

void Term():{}
{
   < INTEGER_LITERAL > |
   < BOOL > |
   < ID > |
   < THIS > |
   < NEW > (< ID > "("")" | < INT > "[" Expression() "]") |
   //< NEW > < INT > "[" Expression() "]" |
   //< NEW > < ID > "("")" |
   "!" Expression() |
   < LPAREN > Expression()< LPAREN >  }

void ExpList():
{}
{
	   Expression() ( ExpRest() )* |
   "" }

void ExpRest():
{}
{
   "," Expression()
     }
