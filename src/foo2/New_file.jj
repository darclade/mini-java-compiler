/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options{  JDK_VERSION = "1.5";  static = true;}PARSER_BEGIN(javinha)package foo2;

public class javinha{  public static void main(String args []) throws ParseException  {    javinha parser = new javinha(System.in);    while (true)    {      System.out.println("Lendo da entrada:");      System.out.print("Entre com um programa minijava: ");      try      {        switch (javinha.Program())        {          case 0 :           System.out.println("Programa OK.");          break;          case 1 :           System.out.println("Tchau.");          break;          default :           break;        }      }      catch (Exception e)      {        System.out.println("Programa Não OK.");        System.out.println(e.getMessage());        javinha.ReInit(System.in);      }      catch (Error e)      {        System.out.println("ERRO!!");        System.out.println(e.getMessage());        break;      }    }  }}PARSER_END(javinha)SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN : /* OPERATORS */{  < PLUS : "+" >| < MINUS : "-" >| < MULTIPLY : "*" >| < AND : "&&" >
| < LTHEN : "<" >
| < EQUALS : "=" >}

TOKEN:
{
  < BOOLEAN : "boolean" >
}

TOKEN:
{
  < STRING : "String" >
}

TOKEN:
{
  < WHILE : "while" >
}

TOKEN:
{
  < IF : "if" >
}

TOKEN:
{
  < ELSE : "else" >
}

TOKEN :
{
  	< LENGHT : "lenght" >} 
TOKEN : //Class
{
  <  CLASS : "class" >
}
TOKEN :
{  <  RETURN : "return" >
}

TOKEN :
{
  < STATIC : "static" >
}

TOKEN :
{
  < VOID : "void" >
}


TOKEN :
{
  <  MAIN : "main" >
}


TOKEN :
{
  < PUBLIC : "public">}

TOKEN:{  <  EXTENDS : "extends" >}

TOKEN:
{
  < SYSTEM : "System" >
}

TOKEN:
{
  < OUT : "out" >
}

TOKEN:
{
  < PRINTLN : "println" >
}

TOKEN:{
  	< THIS : "this" >}

TOKEN:
{
  < INT : "int" >
}

TOKEN:{
  < NEW : "new" >}

TOKEN : //integers{  < INTEGER_LITERAL : (< DIGIT >)+ >| < #DIGIT : [ "0"-"9" ] >}

TOKEN: //boolean values
{
  < BOOL : "true" | "false" >}
TOKEN:
{
  	< ID : ((< LIT >)(< LIT > | "_" | < INTEGER_LITERAL >)*)+>
	| < #LIT : (([ "A"-"Z" ]) | (["a"-"z"]))+ >}

TOKEN:
{
  < SCOLON : ";" >}

TOKEN:
{
  < COMMA : "," >}

TOKEN:
{
  < DOT : "." >}

TOKEN:
{
  < LPAREN : "(" >}

TOKEN:
{
  < RPAREN : ")" >
}

TOKEN:
{
  < LBRACK: "[" >
}

TOKEN:
{
  < RBRACK : "]" >
}

TOKEN:
{
	  < LCHAVE : "{" >  }

TOKEN:
{
  < RCHAVE : "}" >
}

MORE : {
"//" : IN_SINGLE_LINE_COMMENT
| <"/**" ~["/"]> : IN_FORMAL_COMMENT
| "/*" : IN_MULTI_LINE_COMMENT
}
<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN : {
<SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}
<IN_FORMAL_COMMENT>
SPECIAL_TOKEN : {
<FORMAL_COMMENT: "*/" > : DEFAULT
}
<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN : {
<MULTI_LINE_COMMENT: "*/" > : DEFAULT
}
<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE : {
< ~[] >
}

int Program() :{}{  MainClass() ClassDecl()
  {
    return 0;
  }
| ";"
  {
    return 1;
  }}void MainClass() :{}{  < CLASS > < ID > < LCHAVE > < PUBLIC > < STATIC > < VOID > < MAIN > < LPAREN > < STRING > < LBRACK > < RBRACK > < ID > <RPAREN >
               < LCHAVE > Statement() < RCHAVE > < RCHAVE >}
void ClassDecl() :
{}
{
  //< CLASS > < ID > ("{" ( VarDecl() )* ( MethodDecl() )* "}") |
  < CLASS > < ID > (< EXTENDS > < ID >| {} ) < LCHAVE > VarDecl() ( MethodDecl() )* < RCHAVE > ClassDecl() |
  {}
  

}

void VarDecl():
{}
{				   Type() < ID > < SCOLON > VarDecl() |
				   {}
}

void MethodDecl():
{}
{	   < PUBLIC > Type() < ID > < LPAREN > FormalList() < RPAREN > 
               < LCHAVE > VarDecl() ( Statement() )* < RETURN > Expression()< SCOLON >< RCHAVE >             
}

void FormalList():
{}
{	   Type() < ID > FormalRest()
}

void FormalRest():
{}
{
	   < COMMA > Type()< ID > FormalRest() |
	   {}
}

void Type():
{}
{   < INT > ( < LBRACK > < RBRACK > | {} ) |
   < BOOLEAN > |
   //< INT > |
   < ID >
}

void Statement():
{}
{  < LCHAVE > ( Statement() )* < RCHAVE > |
  < IF > < LPAREN > Expression() < RPAREN > Statement() < ELSE > Statement() |
  < WHILE > < LPAREN > Expression() < RPAREN >  Statement() |
  < SYSTEM > < DOT > < OUT > < DOT > < PRINTLN > < LPAREN > Exp() < RPAREN > < SCOLON > |
  < ID > (< LBRACK > Expression() < RBRACK > | {} ) < EQUALS > Expression()< SCOLON >
  //< ID > "=" Expression()";" |
  //< ID > "[" Expression() "]" "=" Expression()";"
}

void Expression():
{}
{
  Term() Exp()}  


void Exp():
{}
{
   (< PLUS > | < MINUS > | < MULTIPLY> | < AND > | < LTHEN >)+ Term()Exp() |
			   Expression() ( < DOT > ( < LENGHT > | <ID > < LPAREN > ExpList() < RPAREN > ) | < LBRACK > Expression() < RBRACK > ) |
   //Expression() < LBRACK > Expression() < RBRACK > |
   //Expression()"." < LENGHT > |
   //Expression()"." <ID > < LPAREN > ExpList() < RPAREN > |
   {}   
  }

void Term():{}
{
   < INTEGER_LITERAL > |
   < BOOL > |
   < ID > |
   < THIS > < DOT > < ID > < LPAREN > Expression() < RPAREN > |
   < NEW > (< ID > < LPAREN > < RPAREN > | < INT > < LBRACK > Expression() < RBRACK >) |
   //< NEW > < INT > "[" Expression() "]" |
   //< NEW > < ID > "("")" |
   "!" Expression() |
   < LPAREN > Expression()< LPAREN >  }

void ExpList():
{}
{
	   Expression() ( ExpRest() )* |
   {} }

void ExpRest():
{}
{
   < COMMA > Expression()
     }
